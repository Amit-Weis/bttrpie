{"mode":"Text","hardwareTarget":"brain","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START IQ MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END IQ MACROS\n\n\n// Robot configuration code.\ninertial BrainInertial = inertial();\nmotor MotorX = motor(PORT4, true);\nmotor MotorZ = motor(PORT6, true);\nmotor MotorY = motor(PORT12, false);\nbumper ClawBumper = bumper(PORT2);\nmotor MotorClaw = motor(PORT9, false);\n\n\n// generating and setting random seed\nvoid initializeRandomSeed(){\n  wait(100,msec);\n  double xAxis = BrainInertial.acceleration(xaxis) * 1000;\n  double yAxis = BrainInertial.acceleration(yaxis) * 1000;\n  double zAxis = BrainInertial.acceleration(zaxis) * 1000;\n  // Combine these values into a single integer\n  int seed = int(\n    xAxis + yAxis + zAxis\n  );\n  // Set the seed\n  srand(seed); \n}\n\n\n\nvoid vexcodeInit() {\n\n  // Initializing random seed.\n  initializeRandomSeed(); \n}\n\n#pragma endregion VEXcode Generated Robot Configuration\n\n//----------------------------------------------------------------------------\n//                                                                            \n//    Module:       main.cpp                                                  \n//    Author:       {author}                                                  \n//    Created:      {date}                                                    \n//    Description:  IQ project                                                \n//                                                                            \n//----------------------------------------------------------------------------\n\n// Include the IQ Library\n#include \"iq_cpp.h\"\n#include \"algorithm\"\n\n// Allows for easier use of the VEX Library\nusing namespace vex;\n\n// 1 = red\n// 2 = blue \n// 3 = black \n// 4 = white \nconst int goal[11] =    {1,\n                        3,3,\n                       2,1,2,\n                      1,2,1,2,\n                         4};\n\nvoid moveTo(double x,double y,double z);\nvoid grab();\nvoid release();\ndouble const TOOTH_PITCH_MM = 4.712;\nint const NUM_TEETH_XY = 12;\nint const NUM_TEETH_Z = 10;\n\nfloat clamp(float val, float low, float high){\n    if (val > high){\n        return high;\n    }\n    else {\n        if (val < low){\n            return low;\n        }\n        else {\n            return val;\n        }\n    }\n}\n\n// x,y,z are coordinates based on the distance from the zero point in mm\nvoid moveToPID(double x, double y, double z) {\n  //  PID constants (tune these per axis) \n  double kP_X = 1, kI_X = 0.0003, kD_X = 0.25;\n  double kP_Y = 1, kI_Y = 0.0003, kD_Y = 0.25;\n  double kP_Z = 1, kI_Z = 0.0003, kD_Z = 0.25;\n\n  //  control loop parameters \n  const double STOP_THRESHOLD = 1;  // mm tolerance\n  const int MAX_POWER = 100;          // percent\n  const int LOOP_DELAY = 20;          // ms\n\n  //  PID state variables \n  double errorX = 0, prevErrorX = 0, integralX = 0;\n  double errorY = 0, prevErrorY = 0, integralY = 0;\n  double errorZ = 0, prevErrorZ = 0, integralZ = 0;\n\n  //  Start moving (direction handled by power sign) \n  MotorX.spin(forward);\n  MotorY.spin(forward);\n  MotorZ.spin(forward);\n\n  while (true) {\n    //  Get current positions in mm \n    double currentX = MotorX.position(turns) * TOOTH_PITCH_MM * NUM_TEETH_XY;\n    double currentY = MotorY.position(turns) * TOOTH_PITCH_MM * NUM_TEETH_XY;\n    double currentZ = MotorZ.position(turns) * TOOTH_PITCH_MM * NUM_TEETH_Z;\n\n    //  Calculate errors \n    errorX = x - currentX;\n    errorY = y - currentY;\n    errorZ = z - currentZ;\n\n    //  Accumulate integral and calculate derivative \n    integralX += errorX;\n    integralY += errorY;\n    integralZ += errorZ;\n\n    double derivativeX = errorX - prevErrorX;\n    double derivativeY = errorY - prevErrorY;\n    double derivativeZ = errorZ - prevErrorZ;\n\n    //  PID output (motor power) \n    double powerX = (kP_X * errorX) + (kI_X * integralX) + (kD_X * derivativeX);\n    double powerY = (kP_Y * errorY) + (kI_Y * integralY) + (kD_Y * derivativeY);\n    double powerZ = (kP_Z * errorZ) + (kI_Z * integralZ) + (kD_Z * derivativeZ);\n\n    //  Clamp motor power \n    //powerX = min(MAX_POWER, max(powerX, -MAX_POWER));\n    //powerY = min(MAX_POWER, max(powerY, -MAX_POWER));\n    //powerZ = min(MAX_POWER, max(powerZ, -MAX_POWER));\n    powerX = clamp(powerX, -MAX_POWER, MAX_POWER); // min(MAX_POWER, max(powerX,-MAX_POWER))\n    powerY = clamp(powerY, -MAX_POWER, MAX_POWER);\n    powerZ = clamp(powerZ, -MAX_POWER, MAX_POWER);\n\n    //  Store previous errors \n    prevErrorX = errorX;\n    prevErrorY = errorY;\n    prevErrorZ = errorZ;\n\n    //  Exit condition: all axes within threshold \n    if (fabs(errorX) < STOP_THRESHOLD &&\n        fabs(errorY) < STOP_THRESHOLD &&\n        fabs(errorZ) < STOP_THRESHOLD) {\n      break;\n    }\n\n    //  stop motors if they are within thresholds \n\n    if (fabs(errorX) < STOP_THRESHOLD) {\n      powerX = 0;\n    }\n     if (fabs(errorY) < STOP_THRESHOLD) {\n      powerY = 0;\n    }\n    if (fabs(errorZ) < STOP_THRESHOLD) {\n      powerZ = 0;\n    }\n\n\n    //  Apply to motors \n    MotorX.setVelocity(powerX, percent);\n    MotorY.setVelocity(powerY, percent);\n    MotorZ.setVelocity(powerZ, percent);\n\n    MotorX.spin(forward);\n    MotorY.spin(forward);\n    MotorZ.spin(forward);\n\n\n    wait(LOOP_DELAY, msec);\n  }\n}\n\n\n\nvoid moveToBallAt(int index) {\n    // Constants for ramp geometry\n    const double THETA = 86 * 3.1415926/180; // ascent angle of the ramp in rads\n    const double RAMP_START_X = 10.0;   // starting X coordinate (cm) for the first ball\n    const double RAMP_START_Z = 2.0;     // starting z coordinate (cm) for the first ball\n    const double RAMP_Y = 5.0;                  // constant Y position for all balls \n    const double BALL_DIAMETER = 3.2;   // cm\n\n    const double X_BALL_SPACING = BALL_DIAMETER * sin(THETA); // measure theta \n    const double Z_BALL_SPACING = BALL_DIAMETER * cos(THETA);  \n\n    // Calculate X and Z based on ball index\n    double x = RAMP_START_X + index * X_BALL_SPACING;\n    double z = RAMP_START_Z + index * Z_BALL_SPACING;\n\n    // Move claw to that ball\n    moveTo(x, RAMP_Y, z);\n}\n\n/*\nint getColorValue() {\n    // get hue in degrees (0–359)\n    int hue = Optical6.hue();\n\n    // convert to 0–255 range\n    int colorValue = (hue * 255) / 360;\n\n    return colorValue;\n}\n\n\nint colorToID(int colorValue) {\n    // Changes these values to the actual values we find later, for now its fine\n\n    if (Optical6.color() == red) {\n        return 1;  \n    } else if (Optical6.color() == blue) {\n        return 2;  // blue\n    } else if (Optical6.color() == white) {\n        return 3;  // white\n    } else if (Optical6.color() == black) {\n        return 4;  // black\n    } else {\n        return 0;  // Unknown / no valid color detected\n    }\n}\n\nvoid collectColours(int currentPositions[11]) {\n    for (int i = 0; i < 10; i++) {\n        // Move claw/sensor to current ball position\n        moveToBallAt(i);\n\n        // Read the color \n        int colorValue = getColorValue();  \n\n        // Convert color reading to an ID (1–4)\n        int ballID = colorToID(colorValue);\n\n        // Store ID in array\n        currentPositions[i] = ballID;\n    }\n}\n\n\n    \nvoid sortBalls(int currentPositions[11]) {\n    for (int i = 0; i < 10; i++) {\n        int targetID = goal[i];  // Get the ID we need at position i\n        int foundIndex = -1;\n        int lastIndex = 10 - i;\n\n        // Find the first ball matching the target ID in the unsorted part\n        for (int j = 0; j <= lastIndex; j++) {\n            if (currentPositions[j] == targetID && foundIndex == -1) {\n                foundIndex = j;\n            }\n        }\n\n        // If we found the target ball\n        if (foundIndex != -1) {\n            // Move to that ball and grab it\n            moveToBallAt(foundIndex);\n            grab();\n\n            // Move to position i\n            moveToBallAt(i);\n            release();\n\n            // Save value of picked ball\n            int pickedBall = currentPositions[foundIndex];\n\n            // Shift all balls between foundIndex and end\n            for (int k = foundIndex; k < 10; k++) {\n                currentPositions[k] = currentPositions[k + 1];\n            }\n\n            // Place the target ball at end\n            currentPositions[10] = pickedBall;\n        }\n        else {\n          Brain.Screen.clearScreen();\n          Brain.Screen.setCursor(1,1);\n          Brain.Screen.print(\"Ball ID of %d not found\", targetID);\n        }\n    }\n}\n*/\n\nvoid calibrate(){\n  int NORMAL_VELOCITY = 40;\n  int APPROACH_VELOCITY = 10;\n  double APPROACH_DISTANCE = 0.3;     // turns\n\n  // CALIBRATE Z:\n  MotorClaw.spin(forward);\n  MotorClaw.setVelocity(-1,percent);\n  MotorZ.spin(forward);\n  MotorZ.setVelocity(NORMAL_VELOCITY,percent);\n\n  while(!ClawBumper.pressing()){}\n  double tempPosZ = MotorZ.position(turns);\n  MotorZ.setVelocity(-APPROACH_VELOCITY,percent);\n\n  while(!(MotorZ.position(turns) <= tempPosZ - APPROACH_DISTANCE)){}\n  MotorZ.setVelocity(APPROACH_VELOCITY,percent);\n\n  while(!ClawBumper.pressing()){}\n  MotorZ.setPosition(0,turns); // z-axis zeroed\n\n  moveToPID(0,0,-10);\n  MotorZ.stop(hold);\n\n\n  // CALIBRATE Y:\n  MotorY.spin(forward);\n  MotorY.setVelocity(NORMAL_VELOCITY,percent);\n\n  while(!ClawBumper.pressing()){}\n  double tempPosY = MotorY.position(turns);\n  MotorY.setVelocity(-APPROACH_VELOCITY,percent);\n\n  while(!(MotorY.position(turns) <= tempPosY - APPROACH_DISTANCE)){}\n  MotorY.setVelocity(APPROACH_VELOCITY,percent);\n\n  while(!ClawBumper.pressing()){}\n  MotorY.setPosition(0,turns); // z-axis zeroed\n  moveToPID(0,-20,-5);\n\n  // CALIBRATE X;\n  MotorX.spin(forward);\n  MotorX.setVelocity(NORMAL_VELOCITY,percent);\n\n  while(!ClawBumper.pressing()){}\n  double tempPosX = MotorX.position(turns);\n  MotorX.setVelocity(-APPROACH_VELOCITY,percent);\n\n  while(!(MotorX.position(turns) <= tempPosX - APPROACH_DISTANCE)){}\n  MotorX.setVelocity(APPROACH_VELOCITY,percent);\n\n  while(!ClawBumper.pressing()){}\n  MotorX.setPosition(0,turns); // z-axis zeroed\n  moveToPID(-350,-50,-50);\n  MotorClaw.stop();\n  MotorX.stop();\n  MotorY.stop();\n  MotorZ.stop();\n}\n\nint main() {\n  // Initializing Robot Configuration. DO NOT REMOVE!\n  vexcodeInit();\n  // Begin project code\n  calibrate();\n  MotorX.stop();\n  MotorY.stop();\n  MotorZ.stop();\n}\n","textLanguage":"cpp","robotConfig":[{"port":[4],"name":"MotorX","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[6],"name":"MotorZ","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[12],"name":"MotorY","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[2],"name":"ClawBumper","customName":true,"deviceType":"Bumper","deviceClass":"bumper","setting":{},"triportSourcePort":22},{"port":[9],"name":"MotorClaw","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22}],"slot":0,"platform":"IQ","sdkVersion":"20230818.11.00.00","appVersion":"4.62.0","fileFormat":"2.0.0","targetBrainGen":"Second","v5SoundsEnabled":false,"aiVisionSettings":{"colors":[],"codes":[],"tags":true,"AIObjects":true,"AIObjectModel":[],"aiModelDropDownValue":""}}