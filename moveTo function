// Include the IQ Library
#include "iq_cpp.h"
#include "cmath"

double const TOOTH_PITCH_MM = 4.712;
int const NUM_TEETH_XY = 12;
int const NUM_TEETH_Z = 10;

using namespace vex;

// x,y,z are coordinates based on the distance from the zero point in mm
void moveTo(double x, double y, double z){
  double STOP_THRESHOLD = 1.0;
  double APPROACH_DISTANCE = 30.0;
  int APPROACH_VELOCITY = 10;
  int NORMAL_VELOCITY = 50;

  MotorX.spin(forward);
  MotorY.spin(forward);
  MotorZ.spin(forward);

  // reverse motors when necessary 
  if(MotorX.position(turns) < 0){
    MotorX.spin(reverse);
  }
  if(MotorY.position(turns) < 0){
    MotorY.spin(reverse);
  }
  if(MotorZ.position(turns) < 0){
    MotorZ.spin(reverse);
  }

  MotorX.setVelocity(NORMAL_VELOCITY,percent);
  MotorY.setVelocity(NORMAL_VELOCITY,percent);
  MotorZ.setVelocity(NORMAL_VELOCITY,percent);

  // moving loop checks
  bool done = false;
  bool doneX = false;
  bool doneY = false;
  bool doneZ = false;
  bool approachingX = false;
  bool approachingY = false;
  bool approachingZ = false;

  // simultanious moving for each axis loop
  while(!done){
    double currentX = MotorX.position(turns) * TOOTH_PITCH_MM * NUM_TEETH_XY;
    double currentY = MotorY.position(turns) * TOOTH_PITCH_MM * NUM_TEETH_XY;
    double currentZ = MotorZ.position(turns) * TOOTH_PITCH_MM * NUM_TEETH_Z;
    double distToX = std::abs(x - currentX);
    double distToY = std::abs(y - currentY);
    double distToZ = std::abs(z - currentZ);

    // slow down motors individually when within approach distance
    if(!approachingX && distToX < APPROACH_DISTANCE){
      MotorX.setVelocity(APPROACH_VELOCITY,percent);
      approachingX = true;
    }
    if(!approachingY && distToY < APPROACH_DISTANCE){
      MotorY.setVelocity(APPROACH_VELOCITY,percent);
      approachingY = true;
    }
    if(!approachingZ && distToZ < APPROACH_DISTANCE){
      MotorZ.setVelocity(APPROACH_VELOCITY,percent);
      approachingZ = true;
    }

    // stop motors individually when within a certain threshold
    if(distToX < STOP_THRESHOLD){
      MotorX.stop();
      doneX = true;
    }
    if(distToY < STOP_THRESHOLD){
      MotorY.stop();
      doneY = true;
    }
    if(distToZ < STOP_THRESHOLD){
      MotorZ.stop();
      doneZ = true;
    }

    // stop loop when done everything
    if(doneX && doneY && doneZ){
      done = true;
    }
  }
}
