{"mode":"Text","hardwareTarget":"brain","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START IQ MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END IQ MACROS\n\n\n// Robot configuration code.\ninertial BrainInertial = inertial();\noptical Optical6 = optical(PORT6);\nmotor MotorX = motor(PORT1, false);\nmotor MotorY = motor(PORT2, false);\nmotor MotorZ = motor(PORT3, false);\n\n\n// generating and setting random seed\nvoid initializeRandomSeed(){\n  wait(100,msec);\n  double xAxis = BrainInertial.acceleration(xaxis) * 1000;\n  double yAxis = BrainInertial.acceleration(yaxis) * 1000;\n  double zAxis = BrainInertial.acceleration(zaxis) * 1000;\n  // Combine these values into a single integer\n  int seed = int(\n    xAxis + yAxis + zAxis\n  );\n  // Set the seed\n  srand(seed); \n}\n\n// Converts a color to a string\nconst char* convertColorToString(color col) {\n  if (col == colorType::red) return \"red\";\n  else if (col == colorType::green) return \"green\";\n  else if (col == colorType::blue) return \"blue\";\n  else if (col == colorType::white) return \"white\";\n  else if (col == colorType::yellow) return \"yellow\";\n  else if (col == colorType::orange) return \"orange\";\n  else if (col == colorType::purple) return \"purple\";\n  else if (col == colorType::cyan) return \"cyan\";\n  else if (col == colorType::black) return \"black\";\n  else if (col == colorType::transparent) return \"transparent\";\n  else if (col == colorType::red_violet) return \"red_violet\";\n  else if (col == colorType::violet) return \"violet\";\n  else if (col == colorType::blue_violet) return \"blue_violet\";\n  else if (col == colorType::blue_green) return \"blue_green\";\n  else if (col == colorType::yellow_green) return \"yellow_green\";\n  else if (col == colorType::yellow_orange) return \"yellow_orange\";\n  else if (col == colorType::red_orange) return \"red_orange\";\n  else if (col == colorType::none) return \"none\";\n  else return \"unknown\";\n}\n\n\n// Convert colorType to string\nconst char* convertColorToString(colorType col) {\n  if (col == colorType::red) return \"red\";\n  else if (col == colorType::green) return \"green\";\n  else if (col == colorType::blue) return \"blue\";\n  else if (col == colorType::white) return \"white\";\n  else if (col == colorType::yellow) return \"yellow\";\n  else if (col == colorType::orange) return \"orange\";\n  else if (col == colorType::purple) return \"purple\";\n  else if (col == colorType::cyan) return \"cyan\";\n  else if (col == colorType::black) return \"black\";\n  else if (col == colorType::transparent) return \"transparent\";\n  else if (col == colorType::red_violet) return \"red_violet\";\n  else if (col == colorType::violet) return \"violet\";\n  else if (col == colorType::blue_violet) return \"blue_violet\";\n  else if (col == colorType::blue_green) return \"blue_green\";\n  else if (col == colorType::yellow_green) return \"yellow_green\";\n  else if (col == colorType::yellow_orange) return \"yellow_orange\";\n  else if (col == colorType::red_orange) return \"red_orange\";\n  else if (col == colorType::none) return \"none\";\n  else return \"unknown\";\n}\n\n\nvoid vexcodeInit() {\n\n  // Initializing random seed.\n  initializeRandomSeed(); \n}\n\n#pragma endregion VEXcode Generated Robot Configuration\n\n//----------------------------------------------------------------------------\n//                                                                            \n//    Module:       main.cpp                                                  \n//    Author:       {author}                                                  \n//    Created:      {date}                                                    \n//    Description:  IQ project                                                \n//                                                                            \n//----------------------------------------------------------------------------\n\n// Include the IQ Library\n#include \"iq_cpp.h\"\n\n// Allows for easier use of the VEX Library\nusing namespace vex;\n\n// 1 = red\n// 2 = blue \n// 3 = black \n// 4 = white \nconst int goal[11] =    {1,\n                        3,3,\n                       2,1,2,\n                      1,2,1,2,\n                         4};\n\nvoid moveTo(double x,double y,double z);\nvoid grab();\nvoid release();\ndouble const TOOTH_PITCH_MM = 4.712;\nint const NUM_TEETH_XY = 12;\nint const NUM_TEETH_Z = 10;\n\n// x,y,z are coordinates based on the distance from the zero point in mm\nvoid moveToPID(double x, double y, double z) {\n  //  PID constants (tune these per axis) \n  double kP_X = 0.4, kI_X = 0.0003, kD_X = 0.25;\n  double kP_Y = 0.4, kI_Y = 0.0003, kD_Y = 0.25;\n  double kP_Z = 0.4, kI_Z = 0.0003, kD_Z = 0.25;\n\n  //  control loop parameters \n  const double STOP_THRESHOLD = 0.1;  // mm tolerance\n  const int MAX_POWER = 100;          // percent\n  const int LOOP_DELAY = 20;          // ms\n\n  //  PID state variables \n  double errorX = 0, prevErrorX = 0, integralX = 0;\n  double errorY = 0, prevErrorY = 0, integralY = 0;\n  double errorZ = 0, prevErrorZ = 0, integralZ = 0;\n\n  //  Reset motor encoders \n  MotorX.resetPosition();\n  MotorY.resetPosition();\n  MotorZ.resetPosition();\n\n  //  Start moving (direction handled by power sign) \n  MotorX.spin(forward);\n  MotorY.spin(forward);\n  MotorZ.spin(forward);\n\n  bool done = false;\n\n  while (!done) {\n    //  Get current positions in mm \n    double currentX = MotorX.position(turns) * TOOTH_PITCH_MM * NUM_TEETH_XY;\n    double currentY = MotorY.position(turns) * TOOTH_PITCH_MM * NUM_TEETH_XY;\n    double currentZ = MotorZ.position(turns) * TOOTH_PITCH_MM * NUM_TEETH_Z;\n\n    //  Calculate errors \n    errorX = x - currentX;\n    errorY = y - currentY;\n    errorZ = z - currentZ;\n\n    //  Accumulate integral and calculate derivative \n    integralX += errorX;\n    integralY += errorY;\n    integralZ += errorZ;\n\n    double derivativeX = errorX - prevErrorX;\n    double derivativeY = errorY - prevErrorY;\n    double derivativeZ = errorZ - prevErrorZ;\n\n    //  PID output (motor power) \n    double powerX = (kP_X * errorX) + (kI_X * integralX) + (kD_X * derivativeX);\n    double powerY = (kP_Y * errorY) + (kI_Y * integralY) + (kD_Y * derivativeY);\n    double powerZ = (kP_Z * errorZ) + (kI_Z * integralZ) + (kD_Z * derivativeZ);\n\n    //  Clamp motor power \n    powerX = std::clamp(powerX, -MAX_POWER, MAX_POWER);\n    powerY = std::clamp(powerY, -MAX_POWER, MAX_POWER);\n    powerZ = std::clamp(powerZ, -MAX_POWER, MAX_POWER);\n\n    //  Store previous errors \n    prevErrorX = errorX;\n    prevErrorY = errorY;\n    prevErrorZ = errorZ;\n\n    //  Exit condition: all axes within threshold \n    if (fabs(errorX) < STOP_THRESHOLD &&\n        fabs(errorY) < STOP_THRESHOLD &&\n        fabs(errorZ) < STOP_THRESHOLD) {\n      done = true;\n    }\n\n    // else to exit loop once stop_threshold is reached in all 3 axes\n    else {\n    //  stop motors if they are within thresholds \n      if (fabs(errorX) < STOP_THRESHOLD) {\n        powerX = 0;\n      }\n      if (fabs(errorY) < STOP_THRESHOLD) {\n        powerY = 0;\n      }\n      if (fabs(errorZ) < STOP_THRESHOLD) {\n        powerZ = 0;\n      }\n\n\n      //  Apply to motors \n      MotorX.setVelocity(powerX, percent);\n      MotorY.setVelocity(powerY, percent);\n      MotorZ.setVelocity(powerZ, percent);\n\n      MotorX.spin(forward);\n      MotorY.spin(forward);\n      MotorZ.spin(forward);\n\n\n      wait(LOOP_DELAY, msec);\n    }\n  }\n\n  //  Stop motors \n  MotorX.stop();\n  MotorY.stop();\n  MotorZ.stop();\n}\n\n\n\nvoid moveToBallAt(int index) {\n    // Constants for ramp geometry\n    const double THETA = 86 * 3.1415926/180; // ascent angle of the ramp in rads\n    const double RAMP_START_X = 10.0;   // starting X coordinate (cm) for the first ball\n    const double RAMP_START_Z = 2.0;     // starting z coordinate (cm) for the first ball\n    const double RAMP_Y = 5.0;                  // constant Y position for all balls \n    const double BALL_DIAMETER = 3.2;   // cm\n\n    const double X_BALL_SPACING = BALL_DIAMETER * sin(THETA); // measure theta \n    const double Z_BALL_SPACING = BALL_DIAMETER * cos(THETA);  \n\n    // Calculate X and Z based on ball index\n    double x = RAMP_START_X + index * X_BALL_SPACING;\n    double z = RAMP_START_Z + index * Z_BALL_SPACING;\n\n    // Move claw to that ball\n    moveTo(x, RAMP_Y, z);\n}\n\n\nint getColorValue() {\n    // get hue in degrees (0–359)\n    int hue = Optical6.hue();\n\n    // convert to 0–255 range\n    int colorValue = (hue * 255) / 360;\n\n    return colorValue;\n}\n\n\nint colorToID(int colorValue) {\n    // Changes these values to the actual values we find later, for now its fine\n\n    if (Optical6.color() == red) {\n        return 1;  \n    } else if (Optical6.color() == blue) {\n        return 2;  // blue\n    } else if (Optical6.color() == white) {\n        return 3;  // white\n    } else if (Optical6.color() == black) {\n        return 4;  // black\n    } else {\n        return 0;  // Unknown / no valid color detected\n    }\n}\nvoid collectColours(int currentPositions[11]) {\n    for (int i = 0; i < 10; i++) {\n        // Move claw/sensor to current ball position\n        moveToBallAt(i);\n\n        // Read the color \n        int colorValue = getColorValue();  \n\n        // Convert color reading to an ID (1–4)\n        int ballID = colorToID(colorValue);\n\n        // Store ID in array\n        currentPositions[i] = ballID;\n    }\n}\n\n\n    \nvoid sortBalls(int currentPositions[11]) {\n    for (int i = 0; i < 10; i++) {\n        int targetID = goal[i];  // Get the ID we need at position i\n        int foundIndex = -1;\n        int lastIndex = 10 - i;\n\n        // Find the first ball matching the target ID in the unsorted part\n        for (int j = 0; j <= lastIndex; j++) {\n            if (currentPositions[j] == targetID && foundIndex == -1) {\n                foundIndex = j;\n            }\n        }\n\n        // If we found the target ball\n        if (foundIndex != -1) {\n            // Move to that ball and grab it\n            moveToBallAt(foundIndex);\n            grab();\n\n            // Move to position i\n            moveToBallAt(i);\n            release();\n\n            // Save value of picked ball\n            int pickedBall = currentPositions[foundIndex];\n\n            // Shift all balls between foundIndex and end\n            for (int k = foundIndex; k < 10; k++) {\n                currentPositions[k] = currentPositions[k + 1];\n            }\n\n            // Place the target ball at end\n            currentPositions[10] = pickedBall;\n        }\n        else {\n          Brain.Screen.clearScreen();\n          Brain.Screen.setCursor(1,1);\n          Brain.Screen.print(\"Ball ID of %d not found\", targetID);\n        }\n    }\n}\n\n\nint main() {\n  // Initializing Robot Configuration. DO NOT REMOVE!\n  vexcodeInit();\n  // Begin project code\n  \n}\n","textLanguage":"cpp","robotConfig":[{"port":[6],"name":"Optical6","customName":false,"deviceType":"Optical","deviceClass":"optical","setting":{}},{"port":[1],"name":"MotorX","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"}},{"port":[2],"name":"MotorY","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"}},{"port":[3],"name":"MotorZ","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"}}],"slot":0,"platform":"IQ","sdkVersion":"20230818.11.00.00","appVersion":"4.60.0","fileFormat":"2.0.0","targetBrainGen":"Second","v5SoundsEnabled":false,"aiVisionSettings":{"colors":[],"codes":[],"tags":true,"AIObjects":true,"AIObjectModel":[],"aiModelDropDownValue":""}}